from mrjob.job import MRJob
import numpy as np
# -------------------------------------------------------------------------
'''
    Problem 4: 
    In this problem, you will use mapreduce framework to implement matrix multipication. 
    You could test the correctness of your code by typing `nosetests test4.py` in the terminal.
'''


# --------------------------
class MatMul(MRJob):
    # --------------------------
    ''' 
        Given a matrix A and a matrix B, compute the product A*B = C
    '''

    # ----------------------
    @staticmethod
    def parse_line(line):
        '''
            parse one line of text from the data file.
            Input:
                    line: one line of text of a data record
            return: 
                    matrix_name: 'A' or 'B' 
                    i: row index, an integer (note, the index starts from 1) 
                    j: column index (note, the index starts from 1) 
                    v: the value of the entry; 
                    nr: number of rows in the matrix C
                    nc: number of columns in the matrix C
        '''
        #########################################
        ## INSERT YOUR CODE HERE

        line = line.strip().split(",")

        matrix_name = line[0]

        i = int(line[1])
        j = int(line[2])
        v = float(line[3])
        nr = int(line[4])
        nc = int(line[5])
        #########################################
        return matrix_name, i, j, v, nr, nc

    # ----------------------
    def mapper(self, in_key, in_value):
        ''' 
            mapper function, which process a key-value pair in the data and generate intermediate key-value pair(s)
            Input:
                    in_key: the key of a data record (in this example, can be ignored)
                    in_value: the value of a data record, (in this example, it is a line of text string in the data file, check 'matrix.csv' for example)
            Yield: 
                    (out_key, out_value) :intermediate key-value pair(s). You need to design the format and meaning of the key-value pairs. These intermediate key-value pairs will be feed to reducers, after grouping all the values with a same key into a value list.
        '''

        # parse one line of text data
        matrix_name, i, j, v, nr, nc = self.parse_line(in_value)

        #########################################
        ## INSERT YOUR CODE HERE
        k = 1
        l = 1
        while (k <= nr) and (l <= nc):
            key = ('C', k, l)
            value = (matrix_name, i, j, v)
            yield (key, value)
            l += 1
            if l > nc:
                l = 1
                k += 1


        #########################################

    # ----------------------
    def reducer(self, in_key, in_values):
        ''' 
            reducer function, which processes a key and value list and produces output key-value pair(s)
            Input:
                    in_key: an intermediate key from the mapper
                    in_values: a list (generator) of values , which contains all the intermediate values with the same key (in_key) generated by all mappers
            Yield: 
                    (out_key, out_value) : output key-value pair(s). 
        '''
        #########################################
        ## INSERT YOUR CODE HERE
        Val = np.stack(in_values)
        C = [0.0] * (len(Val) / 2)
        for i in range(len(Val)):
            if (Val[i][0] == "A") and (float(Val[i][2]) <= (len(Val)/2)) and (float(Val[i][1]) == 1):
                C[i] = float(Val[i][3])
                #print Val[i][1]
                #print C[i]
            if (Val[i][0] == "B") and (float(Val[i][1]) <= (len(Val)/2)) and (float(Val[i][2]) == 1):
                length = i-(len(Val)/2)
                C[length] *= float(Val[i][3])
                #print C
        yield (in_key, float(sum(C)))

        #print C
        #print float(sum(C))
        #########################################
